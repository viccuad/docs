"use strict";(self.webpackChunkkubewarden_docusaurus=self.webpackChunkkubewarden_docusaurus||[]).push([[2929],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return m}});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=p(t),m=o,h=d["".concat(l,".").concat(m)]||d[m]||c[m]||r;return t?a.createElement(h,i(i({ref:n},u),{},{components:t})):a.createElement(h,i({ref:n},u))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,i=new Array(r);i[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var p=2;p<r;p++)i[p]=t[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},506:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return c}});var a=t(3117),o=t(102),r=(t(7294),t(3905)),i=["components"],s={sidebar_label:"Cluster Operators",title:""},l="Before deployment",p={unversionedId:"testing-policies/cluster-operators",id:"testing-policies/cluster-operators",title:"",description:"As a Kubernetes cluster operator you probably want to perform some tests",source:"@site/docs/testing-policies/03-cluster-operators.md",sourceDirName:"testing-policies",slug:"/testing-policies/cluster-operators",permalink:"/testing-policies/cluster-operators",editUrl:"https://github.com/kubewarden/docs/edit/main/docs/testing-policies/03-cluster-operators.md",tags:[],version:"current",lastUpdatedAt:1654161587,formattedLastUpdatedAt:"6/2/2022",sidebarPosition:3,frontMatter:{sidebar_label:"Cluster Operators",title:""},sidebar:"docs",previous:{title:"Policy Authors",permalink:"/testing-policies/policy-authors"},next:{title:"Operator Manual",permalink:"/operator-manual/intro"}},u={},c=[{value:"Install",id:"install",level:2},{value:"Quickstart",id:"quickstart",level:2},{value:"Create <code>AdmissionReview</code> requests",id:"create-admissionreview-requests",level:3},{value:"Test the policy",id:"test-the-policy",level:3},{value:"Automation",id:"automation",level:2}],d={toc:c};function m(e){var n=e.components,t=(0,o.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"before-deployment"},"Before deployment"),(0,r.kt)("p",null,"As a Kubernetes cluster operator you probably want to perform some tests\nagainst a Kubewarden policy you just found."),(0,r.kt)("p",null,"You probably want to answer questions like:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"What are the correct policy settings to get the validation/mutation outcome\nI desire?"),(0,r.kt)("li",{parentName:"ul"},"How can I be sure everything will keep working as expected when I upgrade\nthe policy to a newer version, when I add/change some Kubernetes resources,\nwhen I change the configuration parameters of the policy,...")),(0,r.kt)("p",null,"Kubewarden has a dedicated utility that allows testing of the policies\noutside of Kubernetes, among other operations. This utility is called\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/kubewarden/kwctl"},(0,r.kt)("inlineCode",{parentName:"a"},"kwctl")),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"kwctl")," usage is quite simple, we just have to invoke it with the\nfollowing data as input:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"WebAssembly binary file reference of the policy to be run. The\nKubewarden policy can be loaded from the local filesystem\n(",(0,r.kt)("inlineCode",{parentName:"li"},"file://"),"), an HTTP(s) server (",(0,r.kt)("inlineCode",{parentName:"li"},"https://"),") or an OCI registry\n(",(0,r.kt)("inlineCode",{parentName:"li"},"registry://"),")."),(0,r.kt)("li",{parentName:"ol"},"The admission request object to be evaluated.  This is provided via\nthe ",(0,r.kt)("inlineCode",{parentName:"li"},"--request-path")," argument. The request can be provided through\n",(0,r.kt)("inlineCode",{parentName:"li"},"stdin")," by setting ",(0,r.kt)("inlineCode",{parentName:"li"},"--request-path")," to ",(0,r.kt)("inlineCode",{parentName:"li"},"-"),"."),(0,r.kt)("li",{parentName:"ol"},"The policy settings to be used at evaluation time, they can be\nprovided as an inline JSON via ",(0,r.kt)("inlineCode",{parentName:"li"},"--settings-json")," flag, or a JSON or\nYAML file loaded from the filesystem via ",(0,r.kt)("inlineCode",{parentName:"li"},"--settings-path"),".")),(0,r.kt)("p",null,"Once the policy evaluation is done, ",(0,r.kt)("inlineCode",{parentName:"p"},"kwctl")," prints the\n",(0,r.kt)("inlineCode",{parentName:"p"},"ValidationResponse")," object to the standard output."),(0,r.kt)("h2",{id:"install"},"Install"),(0,r.kt)("p",null,"You can download pre-built binaries of ",(0,r.kt)("inlineCode",{parentName:"p"},"kwctl")," from\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/kubewarden/kwctl/releases"},"here"),"."),(0,r.kt)("h2",{id:"quickstart"},"Quickstart"),(0,r.kt)("p",null,"This section describes how to test the\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/kubewarden/psp-apparmor"},"psp-apparmor")," policy with\ndifferent configurations and validation request objects as input data."),(0,r.kt)("h3",{id:"create-admissionreview-requests"},"Create ",(0,r.kt)("inlineCode",{parentName:"h3"},"AdmissionReview")," requests"),(0,r.kt)("p",null,"We have to create some files holding the ",(0,r.kt)("inlineCode",{parentName:"p"},"AdmissionReview")," objects\nthat will be evaluated by the policy."),(0,r.kt)("p",null,"Let's create a file named ",(0,r.kt)("inlineCode",{parentName:"p"},"pod-req-no-specific-apparmor-profile.json")," with the following\ncontents:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "uid": "1299d386-525b-4032-98ae-1949f69f9cfc",\n  "kind": {\n    "kind": "Pod",\n    "version": "v1"\n  },\n  "object": {\n    "metadata": {\n      "name": "no-apparmor"\n    },\n    "spec": {\n      "containers": [\n        {\n          "image": "nginx",\n          "name": "nginx"\n        }\n      ]\n    }\n  },\n  "operation": "CREATE",\n  "requestKind": {"version": "v1", "kind": "Pod"},\n  "userInfo": {\n    "username": "alice",\n    "uid": "alice-uid",\n    "groups": ["system:authenticated"]\n  }\n}\n')),(0,r.kt)("p",null,"This request tries to create a Pod that doesn't specify any AppArmor\nprofile to be used, that's because it doesn't have an ",(0,r.kt)("inlineCode",{parentName:"p"},"annotation"),"\nwith the ",(0,r.kt)("inlineCode",{parentName:"p"},"container.apparmor.security.beta.kubernetes.io/<name of the\ncontainer>")," key."),(0,r.kt)("p",null,"Let's create a file named ",(0,r.kt)("inlineCode",{parentName:"p"},"pod-req-apparmor-unconfined.json")," with the\nfollowing contents:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "uid": "1299d386-525b-4032-98ae-1949f69f9cfc",\n  "kind": {\n    "kind": "Pod",\n    "version": "v1"\n  },\n  "object": {\n    "metadata": {\n      "name": "privileged-pod",\n      "annotations": {\n        "container.apparmor.security.beta.kubernetes.io/nginx": "unconfined"\n      }\n    },\n    "spec": {\n      "containers": [\n        {\n          "image": "nginx",\n          "name": "nginx"\n        }\n      ]\n    }\n  },\n  "operation": "CREATE",\n  "requestKind": {"version": "v1", "kind": "Pod"},\n  "userInfo": {\n    "username": "alice",\n    "uid": "alice-uid",\n    "groups": ["system:authenticated"]\n  }\n}\n')),(0,r.kt)("p",null,"This request tries to create a Pod with a container called ",(0,r.kt)("inlineCode",{parentName:"p"},"nginx")," that runs\nwith the ",(0,r.kt)("inlineCode",{parentName:"p"},"unconfined")," AppArmor profile. Note well, running in ",(0,r.kt)("inlineCode",{parentName:"p"},"unconfined")," mode\nis a bad security practice."),(0,r.kt)("p",null,"Finally, let's create a file named ",(0,r.kt)("inlineCode",{parentName:"p"},"pod-req-apparmor-custom.json")," with the following\ncontents:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "uid": "1299d386-525b-4032-98ae-1949f69f9cfc",\n  "kind": {\n    "kind": "Pod",\n    "version": "v1"\n  },\n  "object": {\n    "metadata": {\n      "name": "privileged-pod",\n      "annotations": {\n        "container.apparmor.security.beta.kubernetes.io/nginx": "localhost/nginx-custom"\n      }\n    },\n    "spec": {\n      "containers": [\n        {\n          "image": "nginx",\n          "name": "nginx"\n        }\n      ]\n    }\n  },\n  "operation": "CREATE",\n  "requestKind": {"version": "v1", "kind": "Pod"},\n  "userInfo": {\n    "username": "alice",\n    "uid": "alice-uid",\n    "groups": ["system:authenticated"]\n  }\n}\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note well:")," these are stripped down ",(0,r.kt)("inlineCode",{parentName:"p"},"AdmissionReview")," objects, we\nleft only the fields that are relevant to our policy.")),(0,r.kt)("h3",{id:"test-the-policy"},"Test the policy"),(0,r.kt)("p",null,"Now we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"kwctl")," to test the creation of a Pod that doesn't\nspecify an AppArmor profile:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},"$ kwctl run \\\n    --request-path pod-req-no-specific-apparmor-profile.json \\\n    registry://ghcr.io/kubewarden/policies/psp-apparmor:v0.1.4 | jq\n")),(0,r.kt)("p",null,"The policy will accept the request and produce the following output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},'{\n  "uid": "1299d386-525b-4032-98ae-1949f69f9cfc",\n  "allowed": true\n}\n')),(0,r.kt)("p",null,"The policy will instead reject the creation of a Pod with an\n",(0,r.kt)("inlineCode",{parentName:"p"},"unconfined")," AppArmor profile:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},'$ kwctl run \\\n    --request-path pod-req-apparmor-unconfined.json \\\n    registry://ghcr.io/kubewarden/policies/psp-apparmor:v0.1.4 | jq\n{\n  "uid": "1299d386-525b-4032-98ae-1949f69f9cfc",\n  "allowed": false,\n  "status": {\n    "message": "These AppArmor profiles are not allowed: [\\"unconfined\\"]"\n  }\n}\n')),(0,r.kt)("p",null,"Both times we ran the policy ",(0,r.kt)("strong",{parentName:"p"},"without")," providing any kind of\nsetting. As the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/kubewarden/psp-apparmor#configuration"},"policy's\ndocumentation"),"\nstates, this results in preventing the usage of non-default profiles."),(0,r.kt)("p",null,"As a matter of fact, the Pod using a custom ",(0,r.kt)("inlineCode",{parentName:"p"},"nginx")," profile gets rejected by\nthe policy too:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},'$ kwctl run \\\n    --request-path pod-req-apparmor-custom.json \\\n    registry://ghcr.io/kubewarden/policies/psp-apparmor:v0.1.4 | jq\n{\n  "uid": "1299d386-525b-4032-98ae-1949f69f9cfc",\n  "allowed": false,\n  "status": {\n    "message": "These AppArmor profiles are not allowed: [\\"localhost/nginx-custom\\"]"\n  }\n}\n')),(0,r.kt)("p",null,"We can change the default behaviour and allow some chosen AppArmor to be used:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},'$ kwctl run \\\n    --request-path pod-req-apparmor-custom.json \\\n    --settings-json \'{"allowed_profiles": ["runtime/default", "localhost/nginx-custom"]}\' \\\n    registry://ghcr.io/kubewarden/policies/psp-apparmor:v0.1.4 | jq\n')),(0,r.kt)("p",null,"This time the request is accepted:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},'{\n  "uid": "1299d386-525b-4032-98ae-1949f69f9cfc",\n  "allowed": true\n}\n')),(0,r.kt)("h2",{id:"automation"},"Automation"),(0,r.kt)("p",null,"All these steps shown above can be automated using\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/bats-core/bats-core"},"bats"),"."),(0,r.kt)("p",null,"We can write a series of tests and integrate their execution inside of\nyour existing CI and CD pipelines."),(0,r.kt)("p",null,"That would ensure changes to the policy version, policy configuration\nparameters, Kubernetes resources,... won't break the outcome of the\nvalidation/mutation operations."),(0,r.kt)("p",null,'The commands used above can be easily "wrapped" into a ',(0,r.kt)("inlineCode",{parentName:"p"},"bats")," test:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'@test "all is good" {\n  run kwctl run \\\n    --request-path pod-req-no-specific-apparmor-profile.json \\\n    registry://ghcr.io/kubewarden/policies/psp-apparmor:v0.1.4\n\n  # this prints the output when one the checks below fails\n  echo "output = ${output}"\n\n  # request accepted\n  [ $(expr "$output" : \'.*"allowed":true.*\') -ne 0 ]\n}\n\n@test "reject" {\n  run kwctl run \\\n    --request-path pod-req-apparmor-custom.json \\\n    registry://ghcr.io/kubewarden/policies/psp-apparmor:v0.1.4\n\n  # this prints the output when one the checks below fails\n  echo "output = ${output}"\n\n  # request rejected\n  [ $(expr "$output" : \'.*"allowed":false.*\') -ne 0 ]\n}\n')),(0,r.kt)("p",null,"Assuming the snippet from above is inside of a file called ",(0,r.kt)("inlineCode",{parentName:"p"},"e2e.bats"),",\nwe can run the test in this way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"$ bats e2e.bats\n \u2713 all is good\n \u2713 reject\n\n2 tests, 0 failures\n")),(0,r.kt)("p",null,"Checkout ",(0,r.kt)("a",{parentName:"p",href:"/writing-policies/go/e2e-tests"},"this section")," of the\ndocumentation to learn more about writing end-to-end tests of your\npolicies."))}m.isMDXComponent=!0}}]);