"use strict";(self.webpackChunkkubewarden_docusaurus=self.webpackChunkkubewarden_docusaurus||[]).push([[2048],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>g});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=d(n),m=i,g=c["".concat(l,".").concat(m)]||c[m]||p[m]||o;return n?a.createElement(g,r(r({ref:t},u),{},{components:n})):a.createElement(g,r({ref:t},u))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:i,r[1]=s;for(var d=2;d<o;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8998:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=n(87462),i=(n(67294),n(3905));const o={sidebar_label:"Creating a new mutation policy",title:"Creating a new mutation policy",description:"Creating a new mutation policy using Rust",keywords:["kubewarden","kubernetes","creating a new mutation policy","mutation policy","rust"],"doc-type":["tutorial"],"doc-topic":["kubewarden","writing-policies","rust","new-mutation-policy"],"doc-persona":["kubewarden-developer","kubewarden-developer-rust"]},r=void 0,s={unversionedId:"writing-policies/rust/mutation-policy",id:"writing-policies/rust/mutation-policy",title:"Creating a new mutation policy",description:"Creating a new mutation policy using Rust",source:"@site/docs/writing-policies/rust/05-mutation-policy.md",sourceDirName:"writing-policies/rust",slug:"/writing-policies/rust/mutation-policy",permalink:"/next/writing-policies/rust/mutation-policy",draft:!1,editUrl:"https://github.com/kubewarden/docs/edit/main/docs/writing-policies/rust/05-mutation-policy.md",tags:[],version:"current",lastUpdatedAt:1701174300,formattedLastUpdatedAt:"Nov 28, 2023",sidebarPosition:5,frontMatter:{sidebar_label:"Creating a new mutation policy",title:"Creating a new mutation policy",description:"Creating a new mutation policy using Rust",keywords:["kubewarden","kubernetes","creating a new mutation policy","mutation policy","rust"],"doc-type":["tutorial"],"doc-topic":["kubewarden","writing-policies","rust","new-mutation-policy"],"doc-persona":["kubewarden-developer","kubewarden-developer-rust"]},sidebar:"docs",previous:{title:"Writing validation logic",permalink:"/next/writing-policies/rust/write-validation-logic"},next:{title:"Logging",permalink:"/next/writing-policies/rust/logging"}},l={},d=[{value:"Write the mutation code",id:"write-the-mutation-code",level:2},{value:"Update the unit tests",id:"update-the-unit-tests",level:2}],u={toc:d},c="wrapper";function p(e){let{components:t,...n}=e;return(0,i.kt)(c,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Mutating policies are similar to validating ones,\nbut also have the ability to mutate an incoming object."),(0,i.kt)("p",null,"They can:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Reject a request"),(0,i.kt)("li",{parentName:"ul"},"Accept a request without changing the incoming object"),(0,i.kt)("li",{parentName:"ul"},"Mutate the incoming object as they need to and accept the request")),(0,i.kt)("p",null,"Writing a Kubewarden mutation policy is uncomplicated.\nYou'll use the validating policy created in the previous sections,\nand with a few changes,\nturn it into a mutating one."),(0,i.kt)("p",null,"Your policy uses the same validation logic defined before,\nbut it also adds an annotation to all the Pods that have a valid name."),(0,i.kt)("p",null,"Attempting to create a Pod like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx\nspec:\n  containers:\n    - name: nginx\n      image: nginx:latest\n")),(0,i.kt)("p",null,"Leads to the creation of this Pod:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx\n  annotations:\n    kubewarden.policy.demo/inspected: true\nspec:\n  containers:\n    - name: nginx\n      image: nginx:latest\n")),(0,i.kt)("h2",{id:"write-the-mutation-code"},"Write the mutation code"),(0,i.kt)("p",null,"The mutation code is in the ",(0,i.kt)("inlineCode",{parentName:"p"},"validate")," function.\nYou should change this function to approve the request using\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.rs/kubewarden-policy-sdk/0.1.0/kubewarden_policy_sdk/fn.mutate_request.html"},(0,i.kt)("inlineCode",{parentName:"a"},"mutate_request")),"\ninstead of\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.rs/kubewarden-policy-sdk/0.1.0/kubewarden_policy_sdk/fn.accept_request.html"},(0,i.kt)("inlineCode",{parentName:"a"},"accept_request")),"."),(0,i.kt)("p",null,"This is how the ",(0,i.kt)("inlineCode",{parentName:"p"},"validate")," function in ",(0,i.kt)("inlineCode",{parentName:"p"},"lib.rs")," should look:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},'fn validate(payload: &[u8]) -> CallResult {\n    let validation_request: ValidationRequest<Settings> = ValidationRequest::new(payload)?;\n\n    info!(LOG_DRAIN, "starting validation");\n    if validation_request.request.kind.kind != apicore::Pod::KIND {\n        warn!(LOG_DRAIN, "Policy validates Pods only. Accepting resource"; "kind" => &validation_request.request.kind.kind);\n        return kubewarden::accept_request();\n    }\n\n    match serde_json::from_value::<apicore::Pod>(validation_request.request.object) {\n        // NOTE 1\n        Ok(mut pod) => {\n            let pod_name = pod.metadata.name.clone().unwrap_or_default();\n            if validation_request\n                .settings\n                .invalid_names\n                .contains(&pod_name)\n            {\n                kubewarden::reject_request(\n                    Some(format!("pod name {:?} is not accepted", pod_name)),\n                    None,\n                    None,\n                    None,\n                )\n            } else {\n                // NOTE 2\n                let mut new_annotations = pod.metadata.annotations.clone().unwrap_or_default();\n                new_annotations.insert(\n                    String::from("kubewarden.policy.demo/inspected"),\n                    String::from("true"),\n                );\n                pod.metadata.annotations = Some(new_annotations);\n\n                // NOTE 3\n                let mutated_object = serde_json::to_value(pod)?;\n                kubewarden::mutate_request(mutated_object)\n            }\n        }\n        Err(_) => {\n            // We were forwarded a request we cannot unmarshal or\n            // understand, just accept it\n            kubewarden::accept_request()\n        }\n    }\n}\n')),(0,i.kt)("p",null,"Compared to the previous code, you have made three changes:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"We defined the ",(0,i.kt)("inlineCode",{parentName:"li"},"pod")," object as mutable, see the ",(0,i.kt)("inlineCode",{parentName:"li"},"mut")," keyword. This is needed because we will extend its ",(0,i.kt)("inlineCode",{parentName:"li"},"metadata.annotations")," attribute. "),(0,i.kt)("li",{parentName:"ol"},"This is the code that takes the existing ",(0,i.kt)("inlineCode",{parentName:"li"},"annotations"),",\nadds the new one, and finally puts the updated ",(0,i.kt)("inlineCode",{parentName:"li"},"annotations")," object back into the original ",(0,i.kt)("inlineCode",{parentName:"li"},"pod")," instance."),(0,i.kt)("li",{parentName:"ol"},"Serialize the ",(0,i.kt)("inlineCode",{parentName:"li"},"pod")," object into a generic ",(0,i.kt)("inlineCode",{parentName:"li"},"serde_json::Value")," and then return a mutation response.")),(0,i.kt)("p",null,"Having done these changes, it's time to run unit tests again:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-console"},'$ cargo test\n   Compiling demo-a v0.1.0 (/home/jhk/projects/suse/tmp/demo)\n    Finished test [unoptimized + debuginfo] target(s) in 0.95s\n     Running unittests src/lib.rs (target/debug/deps/demo_a-634b88b0dcb6e707)\n\nrunning 5 tests\ntest settings::tests::reject_settings_without_a_list_of_invalid_names ... ok\ntest settings::tests::accept_settings_with_a_list_of_invalid_names ... ok\ntest tests::accept_request_with_non_pod_resource ... ok\ntest tests::reject_pod_with_invalid_name ... ok\ntest tests::accept_pod_with_valid_name ... FAILED\n\nfailures:\n\n---- tests::accept_pod_with_valid_name stdout ----\n{"column":5,"file":"src/lib.rs","level":"info","line":34,"message":"starting validation","policy":"sample-policy"}\nthread \'tests::accept_pod_with_valid_name\' panicked at src/lib.rs:98:9:\nSomething mutated with test case: Pod creation with valid name\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::accept_pod_with_valid_name\n\ntest result: FAILED. 4 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n')),(0,i.kt)("p",null,"As you can see, the ",(0,i.kt)("inlineCode",{parentName:"p"},"accept_pod_with_valid_name")," fails because the response contains a mutated object.\nIt looks like our code is working."),(0,i.kt)("h2",{id:"update-the-unit-tests"},"Update the unit tests"),(0,i.kt)("p",null,"You can update the ",(0,i.kt)("inlineCode",{parentName:"p"},"accept_pod_with_valid_name")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"lib.rs")," to look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'#[test]\nfn accept_pod_with_valid_name() -> Result<(), ()> {\n    let mut invalid_names = HashSet::new();\n    invalid_names.insert(String::from("bad_name1"));\n    let settings = Settings { invalid_names };\n\n    let request_file = "test_data/pod_creation.json";\n    let tc = Testcase {\n        name: String::from("Pod creation with valid name"),\n        fixture_file: String::from(request_file),\n        expected_validation_result: true,\n        settings,\n    };\n\n    let res = tc.eval(validate).unwrap();\n    // NOTE 1\n    assert!(\n        res.mutated_object.is_some(),\n        "Expected accepted object to be mutated",\n    );\n\n    // NOTE 2\n    let final_pod =\n        serde_json::from_value::<apicore::Pod>(res.mutated_object.unwrap()).unwrap();\n    let final_annotations = final_pod.metadata.annotations.unwrap();\n    assert_eq!(\n        final_annotations.get_key_value("kubewarden.policy.demo/inspected"),\n        Some((\n            &String::from("kubewarden.policy.demo/inspected"),\n            &String::from("true")\n        )),\n    );\n\n    Ok(())\n}\n')),(0,i.kt)("p",null,"Compared to the first test, there are two changes:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Change the ",(0,i.kt)("inlineCode",{parentName:"li"},"assert!")," statement so that the request is still accepted, but it also includes a mutated object"),(0,i.kt)("li",{parentName:"ol"},"Created a ",(0,i.kt)("inlineCode",{parentName:"li"},"Pod")," instance starting from the mutated object that's part of the response.\nAssert the mutated Pod object has the right ",(0,i.kt)("inlineCode",{parentName:"li"},"metadata.annotations"),".")),(0,i.kt)("p",null,"Run the tests again, this time all shall pass:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"$ cargo test\n   Compiling demo-a v0.1.0 (/home/jhk/projects/suse/tmp/demo)\n    Finished test [unoptimized + debuginfo] target(s) in 1.25s\n     Running unittests src/lib.rs (target/debug/deps/demo_a-634b88b0dcb6e707)\n\nrunning 5 tests\ntest settings::tests::accept_settings_with_a_list_of_invalid_names ... ok\ntest settings::tests::reject_settings_without_a_list_of_invalid_names ... ok\ntest tests::accept_request_with_non_pod_resource ... ok\ntest tests::reject_pod_with_invalid_name ... ok\ntest tests::accept_pod_with_valid_name ... ok\n\ntest result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n")),(0,i.kt)("p",null,"As you can see, the creation of a mutation policy is straightforward."))}p.isMDXComponent=!0}}]);